# Migration `20200929070535-init`

This migration has been generated by Rahul Sethuram at 9/29/2020, 9:05:35 AM.
You can check out the [state of the schema](./schema.prisma) after the migration.

## Database Steps

```sql
CREATE TABLE "balance" (
    "participant" TEXT NOT NULL,
    "assetId" TEXT NOT NULL,
    "to" TEXT NOT NULL,
    "amount" TEXT NOT NULL,
    "processedDeposit" TEXT NOT NULL,
    "channelAddress" TEXT NOT NULL,

    FOREIGN KEY ("channelAddress") REFERENCES "channel"("channelAddress") ON DELETE CASCADE ON UPDATE CASCADE,
PRIMARY KEY ("participant","channelAddress","assetId")
)

CREATE TABLE "channel" (
    "channelAddress" TEXT NOT NULL,
    "publicIdentifierA" TEXT NOT NULL,
    "publicIdentifierB" TEXT NOT NULL,
    "participantA" TEXT NOT NULL,
    "participantB" TEXT NOT NULL,
    "assetIds" TEXT NOT NULL,
    "timeout" TEXT NOT NULL,
    "nonce" INTEGER NOT NULL,
    "merkleRoot" TEXT NOT NULL,
    "channelFactoryAddress" TEXT NOT NULL,
    "channelMastercopyAddress" TEXT NOT NULL,
    "chainId" INTEGER NOT NULL,
    "providerUrl" TEXT NOT NULL,
PRIMARY KEY ("channelAddress")
)

CREATE TABLE "update" (
    "channelAddress" TEXT,
    "channelAddressId" TEXT NOT NULL,
    "fromIdentifier" TEXT NOT NULL,
    "toIdentifier" TEXT NOT NULL,
    "type" TEXT NOT NULL,
    "nonce" INTEGER NOT NULL,
    "amountA" TEXT NOT NULL,
    "amountB" TEXT NOT NULL,
    "toA" TEXT NOT NULL,
    "toB" TEXT NOT NULL,
    "assetId" TEXT NOT NULL,
    "signatureA" TEXT,
    "signatureB" TEXT,
    "totalDepositedA" TEXT,
    "totalDepositedB" TEXT,
    "transferId" TEXT,
    "transferDefinition" TEXT,
    "transferTimeout" TEXT,
    "transferInitialState" TEXT,
    "transferEncodings" TEXT,
    "merkleProofData" TEXT,
    "meta" TEXT,
    "responder" TEXT,
    "transferResolver" TEXT,
    "merkleRoot" TEXT,

    FOREIGN KEY ("channelAddress") REFERENCES "channel"("channelAddress") ON DELETE SET NULL ON UPDATE CASCADE,
PRIMARY KEY ("channelAddressId","nonce")
)

CREATE TABLE "transfer" (
    "transferId" TEXT NOT NULL,
    "routingId" TEXT NOT NULL,
    "initialAmountA" TEXT NOT NULL,
    "initialAmountB" TEXT NOT NULL,
    "initialToA" TEXT NOT NULL,
    "initialToB" TEXT NOT NULL,
    "initialStateHash" TEXT NOT NULL,
    "channelAddress" TEXT,
    "createUpdateChannelAddressId" TEXT,
    "createUpdateNonce" INTEGER,
    "resolveUpdateChannelAddressId" TEXT,
    "resolveUpdateNonce" INTEGER,

    FOREIGN KEY ("createUpdateChannelAddressId","createUpdateNonce") REFERENCES "update"("channelAddressId","nonce") ON DELETE SET NULL ON UPDATE CASCADE,
    FOREIGN KEY ("resolveUpdateChannelAddressId","resolveUpdateNonce") REFERENCES "update"("channelAddressId","nonce") ON DELETE SET NULL ON UPDATE CASCADE,
    FOREIGN KEY ("channelAddress") REFERENCES "channel"("channelAddress") ON DELETE SET NULL ON UPDATE CASCADE,
PRIMARY KEY ("transferId")
)

CREATE UNIQUE INDEX "channel.publicIdentifierA_publicIdentifierB_chainId_unique" ON "channel"("publicIdentifierA", "publicIdentifierB", "chainId")

CREATE UNIQUE INDEX "channel.participantA_participantB_chainId_unique" ON "channel"("participantA", "participantB", "chainId")

CREATE UNIQUE INDEX "update_channelAddress_unique" ON "update"("channelAddress")

CREATE UNIQUE INDEX "transfer.routingId_unique" ON "transfer"("routingId")

CREATE UNIQUE INDEX "transfer_createUpdateChannelAddressId_createUpdateNonce_unique" ON "transfer"("createUpdateChannelAddressId", "createUpdateNonce")

CREATE UNIQUE INDEX "transfer_resolveUpdateChannelAddressId_resolveUpdateNonce_unique" ON "transfer"("resolveUpdateChannelAddressId", "resolveUpdateNonce")
```

## Changes

```diff
diff --git schema.prisma schema.prisma
migration ..20200929070535-init
--- datamodel.dml
+++ datamodel.dml
@@ -1,0 +1,123 @@
+generator client {
+  provider        = "prisma-client-js"
+  previewFeatures = ["connectOrCreate"]
+  binaryTargets   = ["native"]
+}
+
+datasource db {
+  provider = ["postgresql", "sqlite"]
+  url = "***"
+}
+
+model Balance {
+  @@map(name: "balance")
+  participant      String
+  assetId          String
+  to               String
+  amount           String
+  processedDeposit String
+  Channel          Channel @relation(fields: [channelAddress], references: [channelAddress])
+  channelAddress   String
+  @@id([participant, channelAddress, assetId])
+}
+
+model Channel {
+  @@map(name: "channel")
+  channelAddress           String    @id
+  publicIdentifierA        String
+  publicIdentifierB        String
+  participantA             String
+  participantB             String
+  assetIds                 String
+  timeout                  String
+  nonce                    Int
+  merkleRoot               String
+  balances                 Balance[]
+  channelFactoryAddress    String
+  channelMastercopyAddress String
+  chainId                  Int
+  providerUrl              String
+  latestUpdate             Update
+
+  activeTransfers Transfer[]
+
+  @@unique([publicIdentifierA, publicIdentifierB, chainId])
+  @@unique([participantA, participantB, chainId])
+}
+
+model Update {
+  @@map(name: "update")
+  // COMMON PARAMS
+  channelAddress   String?
+  channel          Channel? @relation(fields: [channelAddress], references: [channelAddress])
+  channelAddressId String // required for ID so that relation can be removed
+
+  fromIdentifier String
+  toIdentifier   String
+  type           String
+  nonce          Int
+
+  // balance
+  amountA String
+  amountB String
+  toA     String
+  toB     String
+
+  assetId    String
+  signatureA String?
+  signatureB String?
+
+  // DETAILS
+  // deposit details
+  totalDepositedA String?
+  totalDepositedB String?
+
+  // create details
+  transferId           String?
+  transferDefinition   String?
+  transferTimeout      String?
+  transferInitialState String? // JSON string
+  transferEncodings    String?
+  merkleProofData      String? // proofs.join(",")
+  meta                 String?
+  responder            String?
+
+  // resolve details
+  transferResolver String?
+  merkleRoot       String?
+
+  // setup inferred from channel params
+
+  createdTransfer  Transfer? @relation("CreatedTransfer")
+  resolvedTransfer Transfer? @relation("ResolvedTransfer")
+
+  @@id([channelAddressId, nonce])
+}
+
+model Transfer {
+  @@map(name: "transfer")
+  transferId String @id
+  routingId  String @unique
+
+  createUpdate  Update? @relation(name: "CreatedTransfer", fields: [createUpdateChannelAddressId, createUpdateNonce], references: [channelAddressId, nonce])
+  resolveUpdate Update? @relation(name: "ResolvedTransfer", fields: [resolveUpdateChannelAddressId, resolveUpdateNonce], references: [channelAddressId, nonce])
+
+  // initial balance
+  initialAmountA String
+  initialAmountB String
+  initialToA     String
+  initialToB     String
+
+  initialStateHash String
+
+  channel        Channel? @relation(fields: [channelAddress], references: [channelAddress])
+  channelAddress String?
+
+  // created will always exist
+  createUpdateChannelAddressId String?
+  createUpdateNonce            Int?
+
+  // resolved will not always exist
+  resolveUpdateChannelAddressId String?
+  resolveUpdateNonce            Int?
+}
```


