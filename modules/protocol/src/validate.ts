import {
  UpdateType,
  ChannelUpdate,
  FullChannelState,
  IVectorStore,
  Result,
  IChannelSigner,
  UpdateParams,
  OutboundChannelUpdateError,
  InboundChannelUpdateError,
  IVectorOnchainService,
  Values,
  DEFAULT_TRANSFER_TIMEOUT,
  FullTransferState,
} from "@connext/vector-types";
import { getSignerAddressFromPublicIdentifier } from "@connext/vector-utils";
import { ValidationError } from "ajv";
import { BigNumber, constants, utils } from "ethers";
import pino from "pino";

const { getAddress } = utils;

// This function performs all update *initiator* side validation
// and is called from within the `sync.outbound` function.
// It will return the valid previous state, as well as the valid parameters.
// NOTE: the presence and validity of the values within the parameters should
// be asserted before the operation is put under lock via the schemas +
// `Vector.validateParams`, so this validation should only perform the
// necessary contextual validation
type OutboundValidationResult<T extends UpdateType = any> = Result<
  {
    validParams: UpdateParams<T>;
    validState: FullChannelState;
    activeTransfers: FullTransferState[];
    transfer?: FullTransferState;
  },
  OutboundChannelUpdateError
>;
export async function validateOutbound<T extends UpdateType = any>(
  params: UpdateParams<T>,
  storeService: IVectorStore,
  onchainService: IVectorOnchainService,
  signer: IChannelSigner,
  logger: pino.BaseLogger = pino(),
): Promise<OutboundValidationResult<T>> {
  // Create a helper to handle errors
  const returnError = (
    validationError: Values<typeof ValidationError.reasons>,
    state?: FullChannelState,
    context: any = {},
  ): OutboundValidationResult => {
    return Result.fail(
      new OutboundChannelUpdateError(OutboundChannelUpdateError.reasons.OutboundValidationFailed, params, state, {
        error: validationError,
        ...context,
      }),
    );
  };

  // Grab the channel from the store
  let state = await storeService.getChannelState(params.channelAddress);

  // IFF it is a setup update, you should make sure that the channel does
  // not exist by channel address, then create an empty channel object.
  // Other setup validation will occur within `validateOutboundSetup`
  if (params.type === UpdateType.setup) {
    if (state) {
      return returnError(ValidationError.reasons.ChannelAlreadySetup);
    }
    // The parameters are valid by schema, safe to destructure
    const {
      channelAddress,
      details: { counterpartyIdentifier, networkContext },
    } = params as UpdateParams<typeof UpdateType.setup>;

    state = {
      nonce: 0,
      latestDepositNonce: 0,
      channelAddress,
      timeout: "0",
      participants: [signer.address, getSignerAddressFromPublicIdentifier(counterpartyIdentifier)],
      balances: [],
      lockedBalance: [],
      assetIds: [],
      merkleRoot: constants.HashZero,
      latestUpdate: {} as any,
      networkContext,
      publicIdentifiers: [signer.publicIdentifier, counterpartyIdentifier],
    };
  }

  // If the state is still undefined here, thow an error
  if (!state) {
    return returnError(ValidationError.reasons.ChannelNotFound);
  }

  // Only on create and resolve do you need to assign a transfer to
  // work with
  let transfer: FullTransferState | undefined = undefined;
  switch (params.type) {
    case UpdateType.setup: {
      // Setup param details include:
      // - timeout
      // - counterpartyIdentifier
      // - networkContext
      // There is no need to validate the `channelAddress` here because
      // it is generated by us using `create2MultisigAddress` within the
      // Vector file
      const {
        details: { networkContext, timeout },
      } = params as UpdateParams<typeof UpdateType.setup>;

      // Validate the channel does not already exist by participants
      const byCounterpartySameOrder = await storeService.getChannelStateByParticipants(
        state.participants[0],
        state.participants[1],
        networkContext.chainId,
      );
      const byCounterpartyDifferentOrder = await storeService.getChannelStateByParticipants(
        state.participants[1],
        state.participants[0],
        networkContext.chainId,
      );
      if (byCounterpartyDifferentOrder || byCounterpartySameOrder) {
        return returnError(ValidationError.reasons.ChannelAlreadySetup, state, {
          byCounterpartyDifferentOrder: byCounterpartyDifferentOrder?.channelAddress,
          byCounterpartySameOrder: byCounterpartySameOrder?.channelAddress,
        });
      }

      // Validate that the timeout is above the default
      if (BigNumber.from(timeout).lt(DEFAULT_TRANSFER_TIMEOUT)) {
        return returnError(ValidationError.reasons.SetupTimeoutInvalid, state, {
          timeout,
          minimumTimeout: DEFAULT_TRANSFER_TIMEOUT,
        });
      }

      // TODO: Is there anything to validate on the network context here?
      break;
    }
    case UpdateType.deposit: {
      // Deposit details include:
      // - channelAddress
      // - assetId
      // Both of these should be validated via the schemas. In the outbound
      // validation, there is nothing contextual to validate, since all of
      // the relevant update values are pulled from chain
      break;
    }
    case UpdateType.create: {
      // Create details include:
      // - amount
      // - assetId
      // - transferDefinition
      // - transferInitialState
      // - timeout
      // - encodings
      // - meta (optional)
      // The transferDefinition, assetId, and meta structures are
      // asserted by the schemas

      // Ensure amount === total locked in initial state

      // Ensure participants both have sufficient funds of asset
      // to create the transfer
      // TODO: the params here seem to assume transfers will have
      // a single asset, what about in channel swaps?

      // Ensure the encodings will work properly for the state
      // TODO: can we assert the resolver encodings in a similar way?

      // Ensure the timeout is above the minimum

      // Ensure the `balance` in the transfer initial state is okay
      // (valid addresses, valid amounts)
      // TODO: any other common properties that can be verified about
      // the transfer state at this level
      break;
    }
    case UpdateType.resolve: {
      // Resolve details include:
      // - transferId
      // - transferResolver
      // - meta (optional)
      // The validity of the transferId and meta structures are
      // asserted by the schemas
      const {
        details: { transferId, transferResolver },
      } = params as UpdateParams<typeof UpdateType.resolve>;

      // Transfer should exist in store
      transfer = await storeService.getTransferState(transferId);
      if (!transfer) {
        return returnError(ValidationError.reasons.TransferNotFound, state);
      }

      // Transfer resolver should match stored resolver encoding
      // TODO: no way to assert the correctness of the resolver
      // encoding before this!

      // Everything else is generated from chain, or pulled from
      // already validated items within the store

      // NOTE: any transfer-specific validation is OUT OF SCOPE
      // for this function, and must be injected by the vector
      // consumer on instantiation
      break;
    }
    default: {
      throw new Error(`Unexpected UpdateType in received params: ${params.type}`);
    }
  }

  return Result.ok({
    validParams: params,
    validState: state,
    activeTransfers: await storeService.getActiveTransfers(params.channelAddress),
    transfer,
  });
}

// This function performs all update validation when you are receiving
// a proposed update for the counterparty -- in `sync.inbound` as well
// as `sync.outbound` when you are out of sync but proposed an update

// NOTE: NONE of the parameters here should be assumed valid, since
// this information is passed over the wire and is not validated
// using the defined schemas. Additionally, this function is called
// by `sync.inbound` (primarily), which is registered on a messaging
// callback.

// Als
export async function validateInbound<T extends UpdateType = any>(
  update: ChannelUpdate<T>,
  state: FullChannelState,
  storeService: IVectorStore,
  onchainService: IVectorOnchainService,
  signer: IChannelSigner,
  logger: pino.BaseLogger = pino(),
): Promise<Result<void, InboundChannelUpdateError>> {
  // There is no need to validate items in the state since this will always
  // be a double signed state

  // First, validate all the common fields within the channel update
  const { channelAddress, fromIdentifier, toIdentifier, nonce, assetId } = update;

  // The channel address should not change from the state
  if (channelAddress !== state.channelAddress) {
    return Result.fail(
      new InboundChannelUpdateError(InboundChannelUpdateError.reasons.DifferentChannelAddress, update, state),
    );
  }

  // Channel address should be an address
  if (!isAddress(channelAddress)) {
    return Result.fail(
      new InboundChannelUpdateError(InboundChannelUpdateError.reasons.InvalidChannelAddress, update, state),
    );
  }

  // The identifiers should be the same
  if (JSON.stringify([fromIdentifier, toIdentifier]) !== JSON.stringify([...state.publicIdentifiers])) {
    return Result.fail(
      new InboundChannelUpdateError(InboundChannelUpdateError.reasons.DifferentIdentifiers, update, state),
    );
  }

  // The update nonce should be exactly one more than the state nonce
  if (nonce !== state.nonce + 1) {
    return Result.fail(new InboundChannelUpdateError(InboundChannelUpdateError.reasons.StaleChannel, update, state));
  }

  // Make sure the assetId is a valid address
  if (!isAddress(assetId)) {
    return Result.fail(new InboundChannelUpdateError(InboundChannelUpdateError.reasons.InvalidAssetId, update, state));
  }

  // Validate signatures
  //

  // Then break out into type-specific validation
  switch (update.type) {
    case UpdateType.setup: {
      return validateSetup(update as ChannelUpdate<"setup">, state as FullChannelState<"setup">, logger);
    }
    case UpdateType.deposit: {
      return validateDeposit(update as ChannelUpdate<"deposit">, state as FullChannelState<"deposit">, logger);
    }
    case UpdateType.create: {
      return validateCreate(update as ChannelUpdate<"create">, state as FullChannelState<"create">, logger);
    }
    case UpdateType.resolve: {
      return validateResolve(update as ChannelUpdate<"resolve">, state as FullChannelState<"resolve">, logger);
    }
    default: {
      throw new Error(`Unexpected UpdateType in received update: ${update.type}`);
    }
  }
}

// NOTE: all the below helpers should validate the `details` field
// of the specific update. See the `ChannelUpdateDetailsMap` type

function validateSetup(
  update: ChannelUpdate<"setup">,
  state: FullChannelState<"setup">,
  logger: pino.BaseLogger = pino(),
): Result<undefined, InboundChannelUpdateError> {
  // Validate channel doesnt exist in storage

  // Validate it is the correct channel address

  // Validate public identifiers are correctly formatted and the
  // participants are correctly derived

  // Validate network context has correct addresses
  // TODO: validate factory onchain

  // Validate timeout is reasonable

  // Validate balances and locked value is 0

  // Validate initial nonce + latestDepositNonce
  // TODO: is initial nonce 0 or 1?

  // Validate merkle root is empty hash, assetIds are empty
  logger.error("validateSetup not implemented", { update, state });
  return Result.ok(undefined);
}

function validateDeposit(
  update: ChannelUpdate<"deposit">,
  state: FullChannelState<"deposit">,
  logger: pino.BaseLogger = pino(),
): Result<undefined, InboundChannelUpdateError> {
  // Validate the latest deposit nonce from chain

  // TODO: Best way to reconcile on and offchain balances?
  // Should we check the state balances + lockedVal + update.amount
  // === currentMultisigBalance?
  logger.error("validateDeposit not implemented", { update, state });
  return Result.ok(undefined);
}

function validateCreate(
  update: ChannelUpdate<"create">,
  state: FullChannelState<"create">,
  logger: pino.BaseLogger = pino(),
): Result<undefined, InboundChannelUpdateError> {
  // Validate transfer id

  // Validate transfer definition

  // Validate reasonable timeout

  // Validate tranfer initial state
  // TODO: this will require a provider!

  // Validate transfer encodings are correct
  // TODO: can we get this from chain?

  // Validate merkle proof data

  // Recalculate + validate merkle root
  // TODO: this will require all transfer initial states!
  logger.error("validateCreate not implemented", { update, state });
  return Result.ok(undefined);
}

function validateResolve(
  update: ChannelUpdate<"resolve">,
  state: FullChannelState<"resolve">,
  logger: pino.BaseLogger = pino(),
): Result<undefined, InboundChannelUpdateError> {
  // Validate transfer id

  // Validate transfer definition

  // Validate resolver
  // TODO: define transfer types

  // Validate merkle proof data

  // Recalculate + validate merkle root
  // TODO: this will require all transfer initial states!
  logger.error("validateResolve not implemented", { update, state });
  return Result.ok(undefined);
}

function isAddress(addr: any): boolean {
  if (!addr) return false;
  if (typeof addr !== "string") return false;
  try {
    getAddress(addr);
    return true;
  } catch (e) {
    return false;
  }
}
