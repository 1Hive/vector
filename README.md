# ↗️ Vector
Vector is an ultra-minimal state channel implementation that borrows ideas from the Counterfactual framework, the v1 Connext Payment Channel Hub, and the StateChannels framework.

## Core Principles
Vector uses the following fundamental design principles:
- All channels have two parties
- Channel participants[] are ordered by `initiator, responder`
- The protocol *only* allows for single-turn conditional transfers. The logic for resolving the transfer can have arbitrary complexity so long as it conforms to a base standard around how `balances` are defined. Because the logic can be complex (though only have single "turn" played by the receiver), it is possible to theoretically construct many-turn State Channel applications so long as each state is independently finalizeable. The communication for these "meta"-updates MUST happen entirely out-of-band and be validated by the implementer independently of the protocol.
- Vector uses leader-election/consensus for concurrency control (like CF), rather than using CRDTs like StateChannels

![alt text](https://i.ibb.co/J2cT0dG/Vector-Phases.png)

The core protocol flow has three primary phases:
1. **Leader Election** -- this is done using a distributed lock implementation. Peers queue updates on the lock and execute them serially.
2. **Update Generation** -- a proposed update is generated by the sender in-memory
3. **Syncronization** -- the sender's update is dispatched over the wire. Receiver validates the update, merges the update with their channel, stores the channel, and then acks. Sender receives the ack and stores.

## Sync Protocol
At the core of Vector lies the `sync` protocol. Unlike in CounterFactual, there is only a single protocol -- `sync` is used both when a sender wants to propose a new update to the replicated state, and *also* when peer state has diverged. Because updates are monotonic (nonce += 1), there are only a very limited number of cases within which party states possibly diverge.

For this reason, `sync` takes a higher degree of control over message delivery than CF does. Outbound messages are retried on a timer if they fail, inbound onces are idempotent. Higher-nonced inbound messages are checked against the `ChannelState` latest nonce and dropped if they are duplicates, or saved to store if they aren't.

## Disputes
Vector makes some simplifying assumptions for disputing:
- All "apps" (now just called transfers) are single-turn only. We also explicitly assume that the app state contains a `transfers[]` tuple.
- Rather than keeping track of an `activeApps[]`, we now just include a merkle root within the `ChannelState`. This means that a `TransferState` must include corresponding materials for a proof (gets validated as part of `disputeTransfer()`)
- No more pushing outcomes -- the responsibility for deciding on a final set of balances to be transferred is delegated entirely to the `transferDefinition` code.
- Disputing occurs within a dispute window within which `defund()` and any `disputeTransfer()` calls MUST be made. After the window ends, the channel returns to a "happy" state onchain (including any undisputed transfers). After that point, any *new* disputes/checkpointing MUST happen at a higher nonce than what is already registered onchain.
- After a dispute occurs, both parties must perform a `setup` update that signs a new `defund()` commitment at a higher nonce.

The dispute flow works as follows:
1. A party calls `disputeChannel()` passing in their latest state. This begins the `consensus` phase of the dispute game. The counterparty has the ability to respond with a higher-nonced state within the phase. Note that for now we just wait out the entire phase, but it would be possible to implement a shortcut where if both parties submit updates then the phase can be skipped.
   - Also note that once a dispute has been initiated, the channel should be considered halted. **Neither party should make or accept offchain updates during this time.**
2. After the dispute phase is complete, the latest state of the channel is available onchain. Then, the `exit` phase of the dispute game begins.
3. During the `exit` phase, either party may call `defund()` (via multisig commitment) with an array of `assetId`s to remove those assets from the channel (for both parties).
// TODO this wont work because we'd need to know the assetIds beforehand? hmm - maybe we can do it with another `setup`?
4. It is also possible for either party to dispute transfers directly during this phase. Parties may either call `disputeTransfer()` (via multisig commitment) directly OR may first call `setTransferResolution()` (directly on adjudicator). The latter should be called first when the transfer has been created but not yet resolved offchain and the caller has the means to resolve it. In this case, the caller passes in the initial state of the transfer, along with a resolving update -- if these params pass validation, we call `resolveTransfer()` in the contract at `TransferDefinition` and then save the resulting balances to state. When `disputeTransfer()` is called through the multisig, it takes in latest state -- if the transfer is resolved, it immediately sends the final balances to the `to` addresses in `transfers[]`. Else, it looks onhchain for a `transferResolution` for that `transferId` and uses that resolution to send balanced. If neither work, then it reverts.

## Funding a Channel
//TODO check security

In Vector, channel funding is asymmetric.

The initiator of a channel (as determined by `participants[]`), *must* deposit using the `depositA` function in the `Multisig.sol` contract. The responder of a channel can deposit simply by sending funds to the multisig address.

Calling `depositA` registers Alice's deposit `amount`, `assetId`, `depositNonce` as the latest deposit onchain. This means that Alice's flow for depositing funds is:
1. Call `depositA` with funds
2. Attempt to reconcile the latest deposit in Alice's balance offchain with Bob (i.e. add `deposit.amount` to `balanceA`)
3. If Bob does not reconcile the balance, at any time before her next deposit, Alice can `disputeChannel`, finalize her latest state onchain, and then call `defund()`.

For Alice, `defund()` works by checking the latest state passed in (which is itself validated against the latest state hash registered onchain in `disputeChannel`). If the `state.depositNonce` is equal to deposit nonce from the multisig data, that means that the latest deposit was reconciled against the balance. If the `state.depositNonce` is one behind the deposit nonce onchain, then that means that the the latest deposit was *not* reconciled against the balances. -- Note that all other cases should *never* happen.

In the former case, Alice's balance is equal to her `state.balanceA`. In the latter, her balance is equal to `state.balanceA + multisigData.deposit.amount`.

For Bob, depositing works somewhat similarly:
1. Send funds to multisig directly
2. Attempt to reconcile the latest deposit in Bob's balance offchain with Alice (i.e. add `deposit.amount` to `balanceB`)
3. If Alice does not reconcile the balance, Bob can `disputeChannel` and then `defund` as above.

For Bob, `defund()` will pay out based on the following logic: We calculate Alice's balance as above (including the possibly unmerged latest deposit). Then, Bob's balance is `multisigOnchainBalance - (balanceA(including potential deposit) + lockedBalance)` where `lockedBalance` is the total amount of funds in the channel currently allocated to any transfers. Another way to say the above is that the protocol will assume that any excess funds that are not explicitly a part of Alice's state OR Alice's unmerged deposits OR locked transfer value must belong to Bob.

The above flows have a few consequences:
- Bob can send funds to the multisig at any time with any frequency and eventually reconcile them with his balances
- Alice does not need to do preparatory work before sending her deposit to chain. The onchain part of her deposit is entirely decoupled from offchain reconciliation.
- We need to pass in an `assetId[]` array into `defund()` in order for it to work. This is probably ok as the function should be able to be called multiple times within the dispute window.
- Alice's cannot deposit many times concurrently (we can potentially modify the `multisigData.deposit` to track historic balances and aggregate them to allow this, however)