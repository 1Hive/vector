import {
  UpdateType,
  ChannelUpdate,
  FullChannelState,
  IVectorStore,
  Result,
  IChannelSigner,
  UpdateParams,
  OutboundChannelUpdateError,
  InboundChannelUpdateError,
  IVectorOnchainService,
  Values,
  DEFAULT_TRANSFER_TIMEOUT,
  FullTransferState,
  ChannelCommitmentData,
  ValidationError,
  CreateUpdateDetails,
  ResolveUpdateDetails,
} from "@connext/vector-types";
import { getSignerAddressFromPublicIdentifier, hashTransferState } from "@connext/vector-utils";
import { BigNumber, constants } from "ethers";
import pino from "pino";

import { applyUpdate } from "./update";
import { generateSignedChannelCommitment, validateChannelUpdateSignatures } from "./utils";

// This function performs all update *initiator* side validation
// and is called from within the `sync.outbound` function.
// It will return the valid previous state, as well as the valid parameters.
// NOTE: the presence and validity of the values within the parameters should
// be asserted before the operation is put under lock via the schemas +
// `Vector.validateParams`, so this validation should only perform the
// necessary contextual validation
type OutboundValidationResult<T extends UpdateType = any> = Result<
  {
    validParams: UpdateParams<T>;
    validState: FullChannelState;
    activeTransfers: FullTransferState[];
    transfer?: FullTransferState;
  },
  OutboundChannelUpdateError
>;
export async function validateOutbound<T extends UpdateType = any>(
  params: UpdateParams<T>,
  storeService: IVectorStore,
  signer: IChannelSigner,
): Promise<OutboundValidationResult<T>> {
  // Create a helper to handle errors
  const returnError = (
    validationError: Values<typeof ValidationError.reasons>,
    state?: FullChannelState,
    context: any = {},
  ): OutboundValidationResult => {
    return Result.fail(
      new OutboundChannelUpdateError(OutboundChannelUpdateError.reasons.OutboundValidationFailed, params, state, {
        error: validationError,
        ...context,
      }),
    );
  };

  // Grab the channel from the store
  let state = await storeService.getChannelState(params.channelAddress);

  // IFF it is a setup update, you should make sure that the channel does
  // not exist by channel address, then create an empty channel object.
  // Other setup validation will occur within `validateOutboundSetup`
  if (params.type === UpdateType.setup) {
    if (state) {
      return returnError(ValidationError.reasons.ChannelAlreadySetup);
    }
    // The parameters are valid by schema, safe to destructure
    const {
      channelAddress,
      details: { counterpartyIdentifier, networkContext },
    } = params as UpdateParams<typeof UpdateType.setup>;

    state = {
      nonce: 0,
      channelAddress,
      timeout: "0",
      participants: [signer.address, getSignerAddressFromPublicIdentifier(counterpartyIdentifier)],
      balances: [],
      processedDepositsA: [],
      processedDepositsB: [],
      assetIds: [],
      merkleRoot: constants.HashZero,
      latestUpdate: {} as any,
      networkContext,
      publicIdentifiers: [signer.publicIdentifier, counterpartyIdentifier],
    };
  }

  // If the state is still undefined here, thow an error
  if (!state) {
    return returnError(ValidationError.reasons.ChannelNotFound);
  }

  // Only on create and resolve do you need to assign a transfer to
  // work with
  let transfer: FullTransferState | undefined = undefined;
  switch (params.type) {
    case UpdateType.setup: {
      // Setup param details include:
      // - timeout
      // - counterpartyIdentifier
      // - networkContext
      // There is no need to validate the `channelAddress` here because
      // it is generated by us using `create2MultisigAddress` within the
      // Vector file
      const {
        details: { networkContext, timeout },
      } = params as UpdateParams<typeof UpdateType.setup>;

      // Validate the channel does not already exist by participants
      const byCounterpartySameOrder = await storeService.getChannelStateByParticipants(
        state.participants[0],
        state.participants[1],
        networkContext.chainId,
      );
      const byCounterpartyDifferentOrder = await storeService.getChannelStateByParticipants(
        state.participants[1],
        state.participants[0],
        networkContext.chainId,
      );
      if (byCounterpartyDifferentOrder || byCounterpartySameOrder) {
        return returnError(ValidationError.reasons.ChannelAlreadySetup, state, {
          byCounterpartyDifferentOrder: byCounterpartyDifferentOrder?.channelAddress,
          byCounterpartySameOrder: byCounterpartySameOrder?.channelAddress,
        });
      }

      // Validate that the timeout is above the default
      if (BigNumber.from(timeout).lt(DEFAULT_TRANSFER_TIMEOUT)) {
        return returnError(ValidationError.reasons.SetupTimeoutInvalid, state, {
          timeout,
          minimumTimeout: DEFAULT_TRANSFER_TIMEOUT,
        });
      }

      // TODO: Is there anything to validate on the network context here?
      break;
    }
    case UpdateType.deposit: {
      // Deposit details include:
      // - channelAddress
      // - assetId
      // Both of these should be validated via the schemas. In the outbound
      // validation, there is nothing contextual to validate, since all of
      // the relevant update values are pulled from chain
      break;
    }
    case UpdateType.create: {
      // Create details include:
      // - amount
      // - assetId
      // - transferDefinition
      // - transferInitialState
      // - timeout
      // - encodings
      // - meta (optional)
      // The transferDefinition, assetId, and meta structures are
      // asserted by the schemas

      // Ensure amount === total locked in initial state

      // Ensure participants both have sufficient funds of asset
      // to create the transfer

      // Ensure the encodings will work properly for the state
      // TODO: can we assert the resolver encodings in a similar way?

      // Ensure the timeout is above the minimum

      // Ensure the `balance` in the transfer initial state is okay
      // (valid addresses, valid amounts)
      // TODO: any other common properties that can be verified about
      // the transfer state at this level
      break;
    }
    case UpdateType.resolve: {
      // Resolve details include:
      // - transferId
      // - transferResolver
      // - meta (optional)
      // The validity of the transferId and meta structures are
      // asserted by the schemas
      const {
        details: { transferId, transferResolver },
      } = params as UpdateParams<typeof UpdateType.resolve>;

      // Transfer should exist in store
      transfer = await storeService.getTransferState(transferId);
      if (!transfer) {
        return returnError(ValidationError.reasons.TransferNotFound, state);
      }

      // Transfer resolver should match stored resolver encoding
      // TODO: no way to assert the correctness of the resolver
      // encoding before this!

      // Everything else is generated from chain, or pulled from
      // already validated items within the store

      // NOTE: any transfer-specific validation is OUT OF SCOPE
      // for this function, and must be injected by the vector
      // consumer on instantiation
      break;
    }
    default: {
      throw new Error(`Unexpected UpdateType in received params: ${params.type}`);
    }
  }

  return Result.ok({
    validParams: params,
    validState: state,
    activeTransfers: await storeService.getActiveTransfers(params.channelAddress),
    transfer,
  });
}

// This function performs all update validation when you are receiving
// a proposed update for the counterparty -- in `sync.inbound` as well
// as `sync.outbound` when you are out of sync but proposed an update.
// It will validate the update, apply the update, validate that there
// is at least one signature, and that all signatures present are
// invalid. (Must apply update to validate signatures)

// NOTE: NONE of the parameters here should be assumed valid, since
// this information is passed over the wire and is not validated
// using the defined schemas. Additionally, this function is called
// by `sync.inbound` (primarily), which is registered on a messaging
// callback.
type InboundValidationResult<T extends UpdateType = any> = Result<
  {
    validUpdate: ChannelUpdate<T>;
    nextState: FullChannelState<T>;
    commitment: ChannelCommitmentData;
    activeTransfers: FullTransferState[]; // after applyUpdate
    transfer?: FullTransferState; // after applyUpdate
  },
  InboundChannelUpdateError
>;
export async function validateAndApplyInboundUpdate<T extends UpdateType = any>(
  update: ChannelUpdate<T>,
  state: FullChannelState,
  storeService: IVectorStore,
  onchainService: IVectorOnchainService,
  signer: IChannelSigner,
  logger: pino.BaseLogger = pino(),
): Promise<InboundValidationResult> {
  // Validate + apply the update
  const res = await validateAndApplyChannelUpdate(update, state, storeService, onchainService);
  if (res.isError) {
    return Result.fail(res.getError()!);
  }

  const { nextState, validUpdate, transfer, activeTransfers } = res.getValue()!;

  // Verify at least one signature exists (and any present are valid)
  const sigRes = await validateChannelUpdateSignatures(nextState, validUpdate.signatures, 1);
  if (sigRes) {
    return Result.fail(
      new InboundChannelUpdateError(InboundChannelUpdateError.reasons.BadSignatures, validUpdate, nextState, {
        error: sigRes,
      }),
    );
  }

  // Generate the cosigned commitment
  const signed = await generateSignedChannelCommitment(nextState, signer, validUpdate.signatures);

  // Add the signature to the state
  const signedNextState = { ...nextState, latestUpdate: { ...nextState.latestUpdate, signatures: signed.signatures } };

  // Return the validated update, resultant state, double signed
  // commitment, and the transfer data
  return Result.ok({ validUpdate, nextState: signedNextState, commitment: signed, activeTransfers, transfer });
}

async function validateAndApplyChannelUpdate<T extends UpdateType>(
  update: ChannelUpdate<T>,
  previousState: FullChannelState,
  storeService: IVectorStore,
  onchainService: IVectorOnchainService,
): Promise<
  Result<
    {
      validUpdate: ChannelUpdate<T>;
      nextState: FullChannelState<T>;
      activeTransfers: FullTransferState[]; // after applyUpdate
      transfer?: FullTransferState; // after applyUpdate
    },
    InboundChannelUpdateError
  >
> {
  // Create a helper to handle errors properly
  const returnError = (
    validationError: Values<typeof ValidationError.reasons>,
    state: FullChannelState = previousState,
    context: any = {},
  ): InboundValidationResult => {
    return Result.fail(
      new InboundChannelUpdateError(InboundChannelUpdateError.reasons.InboundValidationFailed, update, state, {
        error: validationError,
        ...context,
      }),
    );
  };

  const { channelAddress, fromIdentifier, toIdentifier, type, nonce, balance, assetId, details } = update;
  // Get the active transfers for the channel
  const previousActiveTransfers = await storeService.getActiveTransfers(channelAddress);

  // Perform all common update validation -- see note above
  // calling function
  // Ensure the toIdentifier is ours

  // Ensure the fromIdentifier is the counterparties

  // Ensure the nonce == previousState.nonce + 1

  // Ensure the assetId is valid

  // Perform update-type specific validation, and get transfer values
  // to manipulate (if needed)
  let transfer: FullTransferState | undefined = undefined;
  let activeTransfers = [...previousActiveTransfers];
  switch (type) {
    case UpdateType.setup: {
      // Ensure the channelAddress is correctly generated

      // Ensure the timeout is reasonable

      // TODO: There is no way to validate the network context,
      // this should either be implemented in the protocol consumer
      // or within the chain service
      break;
    }

    case UpdateType.deposit: {
      // Ensure the balance has been correctly reconciled

      break;
    }
    case UpdateType.create: {
      const {
        transferId,
        transferDefinition,
        transferTimeout,
        transferInitialState,
        transferEncodings,
        meta,
      } = details as CreateUpdateDetails;
      // Ensure the transferId is properly formatted

      // Ensure the transferDefinition is properly formatted

      // If present, ensure the meta is an object

      // Ensure the transferTimeout is above the minimum

      // Ensure the transferInitialState is correctly structured

      // Ensure there is sufficient balance in the channel for the
      // proposed transfer for the appropriate asset

      // Ensure the transferEncoding is correct for the state
      // TODO: no way to verify resolver encodings!

      // Update the active transfers

      // Recreate the merkle tree

      // Ensure the merkleProofData is correct

      // Ensure the same merkleRoot is generated

      // Create the valid transfer object
      transfer = {
        initialBalance: { ...transferInitialState.balance },
        assetId,
        channelAddress,
        transferId,
        transferDefinition,
        transferTimeout,
        initialStateHash: hashTransferState(transferInitialState, transferEncodings[0]),
        channelFactoryAddress: previousState.networkContext.channelFactoryAddress,
        chainId: previousState.networkContext.chainId,
        transferEncodings,
        transferState: { ...transferInitialState },
        meta,
      };
      break;
    }
    case UpdateType.resolve: {
      const {
        transferId,
        transferDefinition,
        transferResolver,
        transferEncodings,
        merkleRoot,
        meta,
      } = details as ResolveUpdateDetails;

      // Ensure transfer exists in store
      const storedTransfer = (await storeService.getTransferState(transferId))!;

      // Get the final transfer balance from contract
      const transferBalanceResult = await onchainService.resolve(
        { ...storedTransfer, transferResolver },
        previousState.networkContext.chainId,
      );

      if (transferBalanceResult.isError) {
        throw transferBalanceResult.getError()!;
      }
      const transferBalance = transferBalanceResult.getValue()!;

      // Update the transfer
      transfer = {
        ...storedTransfer,
        transferResolver,
        transferState: {
          ...storedTransfer.transferState,
          balance: transferBalance,
        },
      };

      // Ensure the transfer exists within the active transfers

      // Ensure the initiators transfer information is the same as ours:
      // - transferDefintion
      // - transferEncodings

      // Verify the balance is the same from update initiator
      // and chain service

      // Update the active transfers
      activeTransfers = previousActiveTransfers.filter(t => t.transferId === transferId);

      // Regenerate the merkle tree

      // Verify the merkle root is correct

      // If exists, verify the meta is an object
      break;
    }
    default: {
      return returnError(ValidationError.reasons.BadUpdateType);
    }
  }

  // Apply the update
  const applyRes = await applyUpdate(update, previousState, transfer);
  if (applyRes.isError) {
    // Returns an inbound channel error, so don't use helper to preserve
    // apply error
    return Result.fail(applyRes.getError()!);
  }

  return Result.ok({ nextState: applyRes.getValue()!, transfer, activeTransfers, validUpdate: update });
}
